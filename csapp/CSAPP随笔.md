>## 1. 计算机系统漫游

总线，连接各个硬件组件的枢纽。

虚拟地址，进程

程序的执行，硬盘 -> 内存 -> 处理器

硬盘，内存，处理器的访问速度为递增，硬盘最慢，处理器的寄存器最快，计算机运行的速度就是在这些存储组件决定，所以高速缓存（SRAM）至关重要，在处理器中有L1, L2, L3这些高速缓存，L1几乎和寄存器一样的访问速度，L2, L3的速度稍逊于L1,但是依然比内存的访问速度快。

>## 2. 信息的表示和处理

* 整数计算可能会出现正负不一致的错误，但是整数计算符合交换，结合律。
* 浮点数计算的符号位不会出错，但是无法满足结合律。


### 十六进制

二进制太繁琐，十进制跟二进制转换比较麻烦，采用十六进制可以解决前面两个问题

二进制，十进制， 十六进制 转换关系
|十进制|十六进制|二进制|
|--|--|--|
|0|0|0|
|1|1|0001|
|2|2|0010|
|3|3|0011|
|4|4|0100|
|5|5|0101|
|6|6|0110|
|7|7|0111|
|8|8|1000|
|9|9|1001|
|10|A|1010|
|11|B|1011|
|12|C|1100|
|13|D|1101|
|14|E|1110|
|5|F|1111|

```
小试牛刀
1. 将0x39A7F8转换为二进制
2. 将二进制1100100101111011转换为十六进制
3. 将0xD5E4C转换为二进制
4. 将二进制1001101110011110110101转换为十六进制

解答
可以根据上面的表格对应的转换

1. 0x39A7F8 -> 001110011010011111111000

二进制转换为十六进制可以从右往左按照四位一组拆分，最后一组不满四位的话可以在左边补0

2. 1100100101111011 ->[1100][1001][0111][1011] -> 0xC97B

3. 0xD5E4C -> 11010101111001001100

4. 1001101110011110110101 -> [0010][0110][1110][0111][1011][0101] -> 0x26E7B5

```

二进制十进制转换

x > 0, x = 2^n, x = 1[n个0]
n = i + 4j; 0<=i<=3

### 位操作

大端法（big endian） 最高有效字节在最前面的方式

小端法（little endian） 最低有效字节在前面的方式

异或， P或Q为真但不同时为真的时候，P异或Q为真

```
//异或妙用， 不借助第三个变量交换（两个相同数异或等于0， x ^ x = 0）
void swap(int *x, int *y) {
    *y = *x ^ *y; 
    *x = *x ^ *y; // 由上一步,*y = *x ^ *y, 所以 *y = *x ^ *x ^ *y = *y 
    *y = *x ^ *y; // 第一步已赋值， *y = *x ^ *y, 上一步已计算出 *x = *y, 所以 *y = *y ^ *x ^ *y = *x
}
```

移位操作

左移， 右边补0

右移

1. 逻辑右移 左边补0
2. 算术右移 左边补最高有效位的值(在处理有符号数的时候很有用) 

Java中``` >>> ```逻辑右移，``` >> ``` 算术右移

### 整数的表示

```
# length = 0 返回值是多少 ?
int sum(int a[], unsigned length) {
    int sum = 0;
    int i;
    for (i = 0; i <= length - 1; i++)
    {
        sum += a[i];
    }
    return sum;
}
# 无符号数的计算结果就算是负数依然没有符号位，一样为无符号数,补码转换为无符号数。
```